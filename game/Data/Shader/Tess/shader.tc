layout(vertices = 3) out;

in vec2 vTexCoord[];
out vec2 tcTexCoord[];

uniform vec3 EyePos;
uniform mat4 CVM;
float lod=100.;



#define ID gl_InvocationID



float GetTessLevel(float Distance0, float Distance1)
{
    float AvgDistance = (Distance0 + Distance1) / 2.0;

	return clamp(lod/(AvgDistance),1,64);
    if (AvgDistance <= 2.0) {
        return 10.0;
    }
    else if (AvgDistance <= 5.0) {
        return 7.0;
    }
    else {
        return 3.0;
    }
	
	
}

float dist(vec4 point)
{
	vec4 pos=point;
	//pos.xyz/=pos.w;
	pos=gl_ModelViewMatrix*pos;
	//pos.xyz/=pos.w;
	if(EyePos==vec3(0.))return 0.0;
	return distance(vec4(EyePos,1.), pos);;
}
void main()
{
	tcTexCoord[ID] = vTexCoord[ID];
	gl_out[ID].gl_Position = gl_in[ID].gl_Position;
	
	if(ID==1){
	float tessLevelInner = 4.0; // controlled by keyboard buttons
	float tessLevelOuter = 4.0;
	gl_TessLevelInner[0] = tessLevelInner; // number of nested primitives to generate
	gl_TessLevelOuter[0] = tessLevelOuter; // times to subdivide first side
	gl_TessLevelOuter[1] = tessLevelOuter; // times to subdivide second side
	gl_TessLevelOuter[2] = tessLevelOuter; // times to subdivide third side
	
	/*
    // Calculate the distance from the camera to the three control points
    float EyeToVertexDistance0 = dist(gl_in[0].gl_Position);
    float EyeToVertexDistance1 = dist(gl_in[1].gl_Position);
    float EyeToVertexDistance2 = dist(gl_in[2].gl_Position);

    // Calculate the tessellation levels
    gl_TessLevelOuter[0] = GetTessLevel(EyeToVertexDistance1, EyeToVertexDistance2);
    gl_TessLevelOuter[1] = GetTessLevel(EyeToVertexDistance2, EyeToVertexDistance0);
    gl_TessLevelOuter[2] = GetTessLevel(EyeToVertexDistance0, EyeToVertexDistance1);
    gl_TessLevelInner[0] = gl_TessLevelOuter[2];*/
	}

}
